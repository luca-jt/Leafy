raytrace the current scene
switchable render backends -> vulkan support
skeletal animations
collision fix -> sequential solver? + better memory allocation + performance, terrain collision, trees
volumetric rendering -> voxels https://eisenwave.github.io/voxel-compression-docs/svo/svo.html
graphics -> https://youtu.be/Uc8FEI5bg3w, screen space effects, reflection with dynamic environment maps, water shader, post-processing: b/w, depth of field
scene files and loading of them -> serialization (serde) -> editor
shadow anti-aliasing -> pcss
cascaded shadow mapping -> dir light shadow maps need projection matrix size parameter
2D animation frames
2D sprite hitboxes with seperate collision checking
raycasting
particle system https://youtu.be/GK0jHlv3e3w | -> glPoints? , variants: facing the cam, decay time (has a distribution), permanent, ... , compute shaders?
ui basics + font rendering + events for ui struct (e.g. dpi scaling, mouse)

full rewrite of the rendering system
shading type in component -> add styles like cell shading -> together in renderable component?
object outlining with stencil buffer
bloom

dont automatically check for transparency in textures and use a flag in the texture in the components
material, normal map and light map integration
different obj loader that also supports mtl files and support mtl files in the engine -> https://github.com/Twinklebear/tobj -> more meshes, skeletons, vertex colors, asset data arena allocator
-> preload an entire scene obj file, store materials and meshes
reducing the mesh clones in algorithms
documentation

use all texture types in the shaders
entity manager asset commands for the new textures
use the vertex colors in renderers and algorithms
material texture loading needs to be independant of the obj file loading because the materialsource can be created independantly
only delete and load by scene -> asset cache instruction references entire scene and not an individual model
correctly treat empty attribute vectors in the mesh loading -> maybe use optionals in the mesh
a mesh has an optional material identifier stored that is used to lookup in the material register
make shure that the paths for the materials and the material textures are fine
